{
  "CombFactorial": {
    "prefix": "CombFactorial",
    "body": [
      "/// 階乗とその逆元を前計算して",
      "/// - 二項係数 nCr",
      "/// - 順列 nPr",
      "/// - 重複組み合わせ nHr",
      "/// を求める構造体",
      "pub struct CombFactorial {",
      "    fac: Vec<Mint>,",
      "    fac_inv: Vec<Mint>,",
      "}",
      "impl CombFactorial {",
      "    /// n までの階乗と逆元を前計算",
      "    pub fn new(n: usize) -> Self {",
      "        let mut fac = vec![Mint::new(1); n];",
      "        let mut fac_inv = vec![Mint::new(1); n];",
      "        for i in 1..n {",
      "            fac[i] = fac[i - 1] * Mint::new(i as u32);",
      "            fac_inv[i] = fac[i].inv();",
      "        }",
      "        Self { fac, fac_inv }",
      "    }",
      "    /// n!",
      "    pub fn factorial(&self, n: usize) -> Mint {",
      "        self.fac[n]",
      "    }",
      "    /// nCr",
      "    pub fn combination(&self, n: usize, r: usize) -> Mint {",
      "        if r > n {",
      "            return Mint::new(0);",
      "        }",
      "        self.fac[n] * self.fac_inv[r] * self.fac_inv[n - r]",
      "    }",
      "    /// nPr",
      "    pub fn permutation(&self, n: usize, r: usize) -> Mint {",
      "        if r > n {",
      "            return Mint::new(0);",
      "        }",
      "        self.fac[n] * self.fac_inv[n - r]",
      "    }",
      "    /// 重複組合せ nHr",
      "    pub fn homogeneous_product(&self, n: usize, r: usize) -> Mint {",
      "        self.combination(n - 1 + r, r)",
      "    }",
      "}"
    ]
  },
  "CombPascal": {
    "prefix": "CombPascal",
    "body": [
      "/// 二項係数 nCr",
      "/// パスカルの三角形で nCr を求める構造体",
      "/// mが合成数の場合(ConbFactorialが使えない場合)に使用する",
      "pub struct CombPascal {",
      "    pascal: Vec<Vec<Mint>>,",
      "}",
      "impl CombPascal {",
      "    /// n までの nCr を前計算",
      "    pub fn new(n: usize) -> Self {",
      "        let mut pascal = vec![vec![Mint::new(0); n + 1]; n + 1];",
      "        pascal[0][0] = Mint::new(1);",
      "        for i in 0..n {",
      "            for j in 0..=i {",
      "                pascal[i + 1][j] = pascal[i + 1][j] + pascal[i][j];",
      "                pascal[i + 1][j + 1] = pascal[i + 1][j + 1] + pascal[i][j];",
      "            }",
      "        }",
      "        Self { pascal }",
      "    }",
      "    /// nCr",
      "    pub fn combination(&self, n: usize, r: usize) -> Mint {",
      "        if r > n {",
      "            return Mint::new(0);",
      "        }",
      "        self.pascal[n][r]",
      "    }",
      "}"
    ]
  },
  "RerootingDP": {
    "prefix": "RerootingDP",
    "body": [
      "#[derive(Clone, Debug)]",
      "///  TODO: Monoid, merge, add_rootを実装してRerootingDPに渡す",
      "pub struct RerootingMonoid {",
      "    size: usize,",
      "    dist_sum: usize,",
      "}",
      "fn merge(a: RerootingMonoid, b: RerootingMonoid) -> RerootingMonoid {",
      "    RerootingMonoid {",
      "        size: a.size + b.size,",
      "        dist_sum: a.dist_sum + b.dist_sum,",
      "    }",
      "}",
      "fn add_root(a: RerootingMonoid) -> RerootingMonoid {",
      "    RerootingMonoid {",
      "        size: a.size + 1,",
      "        dist_sum: a.dist_sum + a.size + 1,",
      "    }",
      "}",
      "/// RerootingDP（全方位木DP）",
      "pub struct RerootingDP<T: Clone + std::fmt::Debug> {",
      "    pub size: usize,",
      "    pub graph: Vec<Vec<usize>>,",
      "    pub identity: T,",
      "    pub merge: fn(T, T) -> T,",
      "    pub add_root: fn(T) -> T,",
      "    pub dp_sub: Vec<T>,",
      "    pub dp_all: Vec<T>,",
      "}",
      "impl<T: Clone + std::fmt::Debug> RerootingDP<T> {",
      "    pub fn new(size: usize, identity: T, merge: fn(T, T) -> T, add_root: fn(T) -> T) -> Self {",
      "        Self {",
      "            size,",
      "            graph: vec![vec![]; size],",
      "            identity: identity.clone(),",
      "            merge,",
      "            add_root,",
      "            dp_sub: vec![identity.clone(); size],",
      "            dp_all: vec![identity.clone(); size],",
      "        }",
      "    }",
      "    pub fn add_edge(&mut self, u: usize, v: usize) {",
      "        self.graph[u].push(v);",
      "        self.graph[v].push(u);",
      "    }",
      "    fn dfs1(&mut self, v: usize, parent: Option<usize>) {",
      "        let neighbors = self.graph[v].clone();",
      "        let mut acc = self.identity.clone();",
      "        for u in neighbors {",
      "            if Some(u) == parent {",
      "                continue;",
      "            }",
      "            self.dfs1(u, Some(v));",
      "            acc = (self.merge)(acc, (self.add_root)(self.dp_sub[u].clone()));",
      "        }",
      "        self.dp_sub[v] = acc;",
      "    }",
      "    fn dfs2(&mut self, v: usize, parent: Option<usize>, acc_from_parent: T) {",
      "        let n = self.graph[v].len();",
      "        let mut dp_l = vec![self.identity.clone(); n + 1];",
      "        let mut dp_r = vec![self.identity.clone(); n + 1];",
      "        let mut neighbor_monoids = vec![self.identity.clone(); n];",
      "        for i in 0..n {",
      "            let u = self.graph[v][i];",
      "            neighbor_monoids[i] = if Some(u) == parent {",
      "                acc_from_parent.clone()",
      "            } else {",
      "                (self.add_root)(self.dp_sub[u].clone())",
      "            };",
      "        }",
      "        for i in 0..n {",
      "            dp_l[i + 1] = (self.merge)(dp_l[i].clone(), neighbor_monoids[i].clone());",
      "        }",
      "        for i in (0..n).rev() {",
      "            dp_r[i] = (self.merge)(dp_r[i + 1].clone(), neighbor_monoids[i].clone());",
      "        }",
      "        self.dp_all[v] = dp_l[n].clone();",
      "        for i in 0..n {",
      "            let u = self.graph[v][i];",
      "            if Some(u) == parent {",
      "                continue;",
      "            }",
      "            let without_u = (self.merge)(dp_l[i].clone(), dp_r[i + 1].clone());",
      "            self.dfs2(u, Some(v), (self.add_root)(without_u));",
      "        }",
      "    }",
      "    pub fn solve(&mut self) -> Vec<T> {",
      "        self.dfs1(0, None);",
      "        self.dfs2(0, None, self.identity.clone());",
      "        self.dp_all.clone()",
      "    }",
      "}"
    ]
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "/// ダイクストラ法",
      "/// - `graph[v]` に `(to, cost)` のタプルを持つ隣接リスト形式",
      "/// - 負のコストは非対応（必要ならBellman-Fordを使う）",
      "/// 返り値: (dist, prev)",
      "/// - dist[v]: 始点からvへの最短距離（i64::MAXなら到達不可）",
      "/// - prev[v]: vに至る直前の頂点（Noneなら未到達）",
      "pub fn dijkstra(graph: &Vec<Vec<(usize, i64)>>, start: usize) -> (Vec<i64>, Vec<Option<usize>>) {",
      "    let n = graph.len();",
      "    let mut dist = vec![i64::MAX; n];",
      "    let mut prev = vec![None; n];",
      "    let mut pq = BinaryHeap::new();",
      "    dist[start] = 0;",
      "    pq.push(Reverse((0, start)));",
      "    while let Some(Reverse((d, v))) = pq.pop() {",
      "        if d > dist[v] {",
      "            continue;",
      "        }",
      "        for &(to, cost) in &graph[v] {",
      "            let nd = d + cost;",
      "            if nd < dist[to] {",
      "                dist[to] = nd;",
      "                prev[to] = Some(v);",
      "                pq.push(Reverse((nd, to)));",
      "            }",
      "        }",
      "    }",
      "    (dist, prev)",
      "}",
      "/// 経路を復元する",
      "/// - start: 始点",
      "/// - goal: 終点",
      "/// - prev: dijkstra() が返した prev ベクタ",
      "pub fn reconstruct_path(start: usize, goal: usize, prev: &Vec<Option<usize>>) -> Vec<usize> {",
      "    let mut path = vec![];",
      "    let mut cur = Some(goal);",
      "    while let Some(v) = cur {",
      "        path.push(v);",
      "        if v == start {",
      "            break;",
      "        }",
      "        cur = prev[v];",
      "    }",
      "    if path.last() != Some(&start) {",
      "        return vec![];",
      "    }",
      "    path.reverse();",
      "    path",
      "}"
    ]
  },
  "eratosthenes": {
    "prefix": "eratosthenes",
    "body": [
      "/// エラトステネスの篩 O(nloglogn)",
      "/// 定数倍改善1: pのforは2..=sqrt(n)で良い",
      "/// 定数倍改善2: qのforはp*p..=nで良い",
      "/// NOTE: 以下は基本形からmin_factorも返すように修正。",
      "/// 素数判定の過程で応用が効くので、このコードに手を加えて利用することもあるかも",
      "fn eratosthenes(n: usize) -> (Vec<usize>, Vec<usize>) {",
      "    let mut is_prime = vec![true; n + 1];",
      "    let mut min_factor = vec![0; n + 1];",
      "    is_prime[0] = false;",
      "    is_prime[1] = false;",
      "    min_factor[0] = 0;",
      "    min_factor[1] = 0;",
      "    for p in 2..=n {",
      "        if !is_prime[p] {",
      "            continue;",
      "        }",
      "        min_factor[p] = p;",
      "        for q in (p * 2..=n).step_by(p) {",
      "            is_prime[q] = false;",
      "            if min_factor[q] == 0 {",
      "                min_factor[q] = p;",
      "            }",
      "        }",
      "    }",
      "    let primes = (0..=n).filter(|&x| is_prime[x]).collect();",
      "    (primes, min_factor)",
      "}"
    ]
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "/// 最大公約数を求めるユークリッドの互除法 O(log(min(a, b)))",
      "fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        return a;",
      "    }",
      "    gcd(b, a % b)",
      "}"
    ]
  },
  "inside": {
    "prefix": "inside",
    "body": [
      "fn inside(i: isize, j: isize, h: usize, w: usize) -> bool {",
      "    0 <= i && i < h as isize && 0 <= j && j < w as isize",
      "}"
    ]
  },
  "lcm": {
    "prefix": "lcm",
    "body": [
      "/// 最大公約数を求めるユークリッドの互除法 O(log(min(a, b)))",
      "fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        return a;",
      "    }",
      "    gcd(b, a % b)",
      "}",
      "/// 最小公倍数 O(log(min(a, b)))",
      "fn lcm(a: usize, b: usize) -> usize {",
      "    a / gcd(a, b) * b",
      "}"
    ]
  },
  "mod_pow": {
    "prefix": "mod_pow",
    "body": [
      "/// 繰り返し二乗法",
      "/// b^e mod m を計算する",
      "/// O(log e) (e<=10^18程度なら間に合う)",
      "fn mod_pow(base: usize, exp: usize, modulus: usize) -> usize {",
      "    let mut result = 1;",
      "    let mut b = base % modulus;",
      "    let mut e = exp;",
      "    while e > 0 {",
      "        if e % 2 == 1 {",
      "            result = (result * b) % modulus;",
      "        }",
      "        b = (b * b) % modulus;",
      "        e /= 2;",
      "    }",
      "    result",
      "}"
    ]
  },
  "next_permutation": {
    "prefix": "next_permutation",
    "body": [
      "fn next_permutation<T: Ord>(a: &mut [T]) -> bool {",
      "    let n = a.len();",
      "    if n < 2 {",
      "        return false;",
      "    }",
      "    let mut i = n - 2;",
      "    while i != usize::MAX && a[i] >= a[i + 1] {",
      "        if i == 0 {",
      "            break;",
      "        }",
      "        i -= 1;",
      "    }",
      "    if i == 0 && a[0] >= a[1] {",
      "        return false;",
      "    }",
      "    let mut j = n - 1;",
      "    while a[j] <= a[i] {",
      "        j -= 1;",
      "    }",
      "    a.swap(i, j);",
      "    a[i + 1..].reverse();",
      "    true",
      "}"
    ]
  },
  "next_pos": {
    "prefix": "next_pos",
    "body": [
      "/// 次の出現位置",
      "/// next[i][c] := 位置i以降で文字cが最初に出現する位置",
      "/// 出現しない場合はs.len()",
      "fn next_pos(s: &[char]) -> Vec<Vec<usize>> {",
      "    let n = s.len();",
      "    let mut next = vec![vec![n; 26]; n + 1];",
      "    for i in (0..n).rev() {",
      "        next[i] = next[i + 1].clone();",
      "        next[i][(s[i] as u8 - b'a') as usize] = i;",
      "    }",
      "    next",
      "}"
    ]
  },
  "prime_factorize": {
    "prefix": "prime_factorize",
    "body": [
      "/// エラトステネスの篩 O(nloglogn)",
      "/// 定数倍改善1: pのforは2..=sqrt(n)で良い",
      "/// 定数倍改善2: qのforはp*p..=nで良い",
      "/// NOTE: 以下は基本形からmin_factorも返すように修正。",
      "/// 素数判定の過程で応用が効くので、このコードに手を加えて利用することもあるかも",
      "fn eratosthenes(n: usize) -> (Vec<usize>, Vec<usize>) {",
      "    let mut is_prime = vec![true; n + 1];",
      "    let mut min_factor = vec![0; n + 1];",
      "    is_prime[0] = false;",
      "    is_prime[1] = false;",
      "    min_factor[0] = 0;",
      "    min_factor[1] = 0;",
      "    for p in 2..=n {",
      "        if !is_prime[p] {",
      "            continue;",
      "        }",
      "        min_factor[p] = p;",
      "        for q in (p * 2..=n).step_by(p) {",
      "            is_prime[q] = false;",
      "            if min_factor[q] == 0 {",
      "                min_factor[q] = p;",
      "            }",
      "        }",
      "    }",
      "    let primes = (0..=n).filter(|&x| is_prime[x]).collect();",
      "    (primes, min_factor)",
      "}",
      "fn fast_prime_factorize(mut n: usize, min_factor: &[usize]) -> Vec<(usize, usize)> {",
      "    let mut res = vec![];",
      "    while n > 1 {",
      "        let p = min_factor[n];",
      "        let mut exp = 0;",
      "        while min_factor[n] == p {",
      "            n /= p;",
      "            exp += 1;",
      "        }",
      "        res.push((p, exp));",
      "    }",
      "    res",
      "}",
      "fn prime_factorize(mut n: usize, primes: &[usize]) -> Vec<(usize, usize)> {",
      "    let mut factors = Vec::new();",
      "    for &p in primes {",
      "        if p * p > n {",
      "            break;",
      "        }",
      "        let mut exp = 0;",
      "        while n % p == 0 {",
      "            n /= p;",
      "            exp += 1;",
      "        }",
      "        if exp > 0 {",
      "            factors.push((p, exp));",
      "        }",
      "    }",
      "    if n > 1 {",
      "        factors.push((n, 1));",
      "    }",
      "    factors",
      "}"
    ]
  },
  "product": {
    "prefix": "product",
    "body": [
      "fn product<T: Clone>(values: &[T], k: usize, current: &mut Vec<T>, results: &mut Vec<Vec<T>>) {",
      "    if current.len() == k {",
      "        results.push(current.clone());",
      "        return;",
      "    }",
      "    for v in values {",
      "        current.push(v.clone());",
      "        product(values, k, current, results);",
      "        current.pop();",
      "    }",
      "}"
    ]
  },
  "topological_sort": {
    "prefix": "topological_sort",
    "body": [
      "fn topological_sort(",
      "    n: usize,",
      "    graph: &Vec<Vec<usize>>,",
      "    indeg: &mut Vec<usize>,",
      ") -> Option<Vec<usize>> {",
      "    let mut heapq = std::collections::BinaryHeap::new();",
      "    for (v, &d) in indeg.iter().enumerate() {",
      "        if d == 0 {",
      "            heapq.push(Reverse(v));",
      "        }",
      "    }",
      "    let mut order = vec![];",
      "    while let Some(Reverse(p)) = heapq.pop() {",
      "        order.push(p + 1);",
      "        for &c in graph[p].iter() {",
      "            indeg[c] -= 1;",
      "            if indeg[c] == 0 {",
      "                heapq.push(Reverse(c));",
      "            }",
      "        }",
      "    }",
      "    if order.len() == n {",
      "        Some(order)",
      "    } else {",
      "        None",
      "    }",
      "}"
    ]
  },
  "u64_floor_sqrt": {
    "prefix": "u64_floor_sqrt",
    "body": [
      "/// 平方根の整数部分を求める関数",
      "fn u64_floor_sqrt(n: u64) -> u64 {",
      "    let tmp = (n as f64).sqrt() as u64;",
      "    let tmp_m1 = tmp.saturating_sub(1);",
      "    if tmp_m1 * (tmp_m1 + 2) < n {",
      "        tmp",
      "    } else {",
      "        tmp_m1",
      "    }",
      "}"
    ]
  }
}
